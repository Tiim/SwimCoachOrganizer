import groovy.xml.MarkupBuilder

import java.time.LocalDate

plugins {
    id 'java'
    id 'application'
    id 'edu.sc.seis.launch4j' version '1.5.1'
    id 'org.hidetake.ssh' version '1.1.3'
    id 'com.github.johnrengelman.shadow' version '1.2.2' //FatJar
}

///////////////////////////////
// CONFIGURATION

//Specify the main class and project version
mainClassName = 'ch.tiim.sco.MainWrapper'
project.ext.dbLocation = 'wd/file.db'
version = getVersionFromGit()

//Min java 1.8 for javafx
sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

//Add dependencies from maven
repositories {
    mavenCentral()
}

dependencies {
    //Log4j
    compile group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.+'
    compile group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.+'
    compile group: 'org.apache.logging.log4j', name: 'log4j-1.2-api', version: '2.+'

    //H2
    compile group: 'com.h2database', name: 'h2', version: '1.4.+'

    //Guava
    compile group: 'com.google.guava', name: 'guava', version: '12.+'

    //JUnit
    testCompile group: 'junit', name: 'junit', version: '4.+'
}

// Remove the file "MainWrapper.java" from the normal compile
// pipeline
sourceSets {
    mwrapper {
        java {
            srcDir 'src/main/java'
            include 'ch/scbirs/sco/MainWrapper.java'
        }
        compileClasspath += main.output
    }
    main {
        java {
            exclude 'ch/scbirs/sco/MainWrapper.java'
        }
    }
    generated {
    }
}
compileJava.source sourceSets.generated.java, sourceSets.main.java

//Specify the content of the manifest
jar {
    doFirst {
        manifest {
            attributes([
                    'Manifest-Version': '1.0',
                    'Main-Class'      : project.mainClassName,
                    'Class-Path'            : configurations.compile.collect { it.getName() }.join(' '),
                    'Implementation-Title'  : 'Swim Coach Organizer',
                    'Implementation-Version': version
            ])
        }
    }
    //Merge the MainWrapper back into the same jar
    from sourceSets.mwrapper.output
    archiveName = baseName + '.' + extension
}

//Set java 1.5 compatibility for the MainWrapper
compileMwrapperJava {
    sourceCompatibility = JavaVersion.VERSION_1_5
    targetCompatibility = JavaVersion.VERSION_1_5
}

//Force rebuild when deploy task in in the task graph
jar {
    outputs.upToDateWhen {
        !gradle.taskGraph.hasTask(deploy)
    }
}

launch4j {
    mainClassName = project.mainClassName
    icon = 'D:\\Dev\\#JProjects\\SwimCoachOrganizer\\res\\icon_win.ico'
    jar = project.shadowJar.archivePath
}

createExeWithJar.dependsOn(shadowJar)

remotes {
    server {
        if (project.hasProperty('ssh_host')) {
            host = ssh_host
            user = ssh_user
            password = ssh_pwd
            port = ssh_port.toInteger()
        } else {
            host = System.getenv('SSH_HOST')
            user = System.getenv('SSH_USER')
            password = System.getenv('SSH_PWD')
            port = System.getenv('SSH_PORT').toInteger()
        }
        knownHosts = allowAnyHosts
        retryCount = 3
    }
}

///////////////////////////////
// TASKS


task metadata << {
    def writer = new OutputStreamWriter(file('build/meta.xml').newOutputStream())
    def xml = new MarkupBuilder(writer)
    xml.metadata() {
        build(version: project.version, date: LocalDate.now())
        launch(arg: "java -jar ${project.name}.jar")
    }
}

//Zip all dependencies that are not the "updater"
//into build/dist.zip
task zipDeps(type: Zip, dependsOn: ['build', 'metadata']) {
    from({ project.configurations.runtime })
    from({ project.jar.archivePath })
    from(file('build/meta.xml'))
    subprojects.each {
        if (it.name != 'Updater') {
            from({ it.jar.archivePath })
        }
    }
    destinationDir = file('build')
    archiveName = 'dist.zip'
}

// Copy "dist.zip" and "Updater.jar" to the dist_location
// or to "build/dist"
// Write version of the project to "version.txt"
// and the version of the updater to "updaterVersion.txt"
task updaterPackage(type: Copy, dependsOn: ['build', ':Updater:build', 'zipDeps']) {
    from({ project(':Updater').jar.archivePath })
    from({ project.zipDeps.archivePath })
    if (project.hasProperty('dist_location')) {
        into dist_location
    } else {
        into 'build/dist'
    }
    doFirst {
        destinationDir.mkdirs()
    }
    doLast {
        (new File(destinationDir, 'version.txt')).write(project.version)
        (new File(destinationDir, 'updaterVersion.txt')).write(project(':Updater').version)
    }
}

task zipL4j(type: Zip, dependsOn: 'launch4j') {
    from('build/launch4j') {
        include 'lib/**'
        include '*.exe'
    }
    destinationDir = file('build/launch4j')
    archiveName "SwimCoachOrganizer-win-${project.version}.zip"
}

task deploy(type: Copy, dependsOn: ['zipL4j', 'distZip', 'distTar']) {
    from('build/launch4j') {
        include "*${project.version}.*"
    }
    from('build/distributions') {
        include "*${project.version}.*"
    }
    destinationDir = file('build/deploy')
    doFirst {
        delete(destinationDir)
        destinationDir.mkdirs()
        file('build/deploy/version.txt').text = project.version
    }
    doLast {
        ssh.run {
            session(remotes.server) {
                execute "mkdir -p ${project.version}"
                put from: fileTree(dir: 'build/deploy', include: '*.*'), into: project.version
            }
        }
    }
}

///////////////////////////////
// FUNCTIONS

// Returns version based on git tag:
// first two blocks are the git tag name,
// third digit is commit number since last tag
String getVersionFromGit() {
    def versionString = 'git describe --tags'.execute().text.trim()

    def pattern = ~/v(\d+)\.(\d+)-(\d+)-?(.*)/
    def major = 0
    def minor = 0
    def patch = 0
    def gitHash = ''

    if (versionString ==~ pattern) {
        def matcher = versionString =~ pattern
        major = matcher[0][1]
        minor = matcher[0][2]
        patch = matcher[0][3]
        gitHash = matcher[0][4]
    } else {
        patch = 1
        gitHash = 'git rev-parse --short HEAD'.execute().text.trim()
    }

    def v = "v${major}.${minor}.${patch}-${gitHash}"

    println "Current version: ${v}"

    return v
}
